# Git&SVN异同

1. 最核心的区别Git是分布式的，而Svn不是分布的。Git跟Svn一样有自己的集中式版本库和Server端，但Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端。
    
    1. Git没有一个全局版本号，而SVN有。
        
        SVN可以有一个递增的全局版本号，而Git和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。因为Git是分布式的版本控制系统，多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。
    
    2. Git下载下来后，在OffLine状态下可以看到所有的Log，SVN不可以。
    
    3. SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。在Git中，每一个Git仓库都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）发生了什麼事，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！
    
    4. 每个开发人员从中心版本库/服务器上`chect out`代码后会在自己的机器上克隆一个自己的版本库。离线状态下仍然能够提交文件，查看历史版本记录，创建项目分支等。
    
    5. SVN提交并非每次都能够成功。如果有其他人先于你提交，会提示“改动基于过时的版本，先更新再提交”。
    
        冲突解决不再像是SVN一样的提交竞赛，而是在需要的时候才进行合并和冲突解决。
    
2. Git把内容按元数据方式存储，而SVN是按文件。

    `第一次修改 -> git add -> 第二次修改 -> git commit`
    Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。而SVN要提交就是整个文件提交，不能只提交文件上部分修改内容。

    克隆一份全新的目录以同样拥有五个分支来说，SVN是同时复製5个版本的文件,也就是说重复五次同样的动作。而Git只是获取文件的每个版本的 *修改*，然后只载入主要的分支(master)
    
3. SVN会在每一个目录置放一个`.svn`。如果想移除这些`.svn`是很累的。
    
    而Git会在目录起点拥有一个`.git`目录，以及`.gitignore`。
    
4. 权限。

    SVN通过对文件目录授权来实现权限管理，子目录默认继承父目录的权限。
    
    Git 的授权做不到Subversion那样精细。Git的授权模型只能实现非零即壹式的授权，要么拥有全部的写权限，要么没有写权限，要么拥有整个版本库的读权限，要么禁用。

## 总结

SVN更适用于项目管理，Git适用于代码管理。

一个研发队伍的成员正常包括：需求分析、设计、美工、程序员、测试、实施、运维，每个成员在工作中都有产出物，  包括了文档、设计代码、程序代码，这些都需要按项目集中进行管理的。SVN能清楚的按目录进行分类管理， 使项目组的管理处于有序高效的状态。

## 权限问题详解

从技术上将，Git可能永远也做不到类似SVN的路径授权（读授权）：

• 如果允许按照路径授权，则各个克隆的关系将不再是平等的关系，有的内容多，有的内容少，分布式的理念被破坏

• 如果只有部分路径可读，则克隆出来的提交和原始提交的提交ID可能不同。因为提交ID是和提交内容有关的，克隆中提交的部分内容被丢弃，势必提交的ID也要重新计算

• 允许全部代码可读，只允许部分代码可写，在版本控制的管理下，是没有多大实际意义的，而且导致了提交的逻辑上的不完整。