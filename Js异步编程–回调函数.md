#Js异步编程--回调函数

[TOC]

你可能知道，Javascript语言的执行环境是"单线程"（single thread）。
所谓"单线程"，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。
![Alt text](./bg2012122101.jpg)
这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。
为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。
"同步模式"就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；"异步模式"则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。
"异步模式"非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，"异步模式"甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。
##回调函数

这是异步编程最基本的方法。
假定有两个函数f1和f2，后者等待前者的执行结果(参考--[js执行顺序](https://github.com/SSSStone/Note/blob/master/js%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.md))。
``` javascript
function f1(){
	//f1的任务代码
};
function f2(){
	//f2的任务代码
};
f1();
f2();
//执行顺序是f(1)->f(2).
```
如果f1是一个很耗时的任务，可以考虑改写f1。
``` javascript
function f1(){
　　setTimeout(function(){ 
		alert("我是f1") 
	},1000); 
}
function f2(){
	alert("我是f2"); 
};
// 执行结果是先弹出“我是f2”，再弹出“我是f1”。
//表明，f1等待的过程中并没有对f2造成阻塞。
```
看上去，f2()和延时程序是分两个过程再走，但其实，这是JavaScript中的“回调”机制在起作用，类似于操作系统中的“中断和响应” —— 延时程序设置一个“中断”，然后执行f2()，待1000毫秒时间到后，再回调执行f1()。
- 优点是简单、容易理解和部署。
- 缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。

